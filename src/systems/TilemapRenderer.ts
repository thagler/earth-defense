import Phaser from 'phaser';
import {
  MapConfig,
  TileType,
  TILE_SIZE,
} from '../config/maps';

/**
 * Tile colors used for rendering the placeholder tilemap.
 */
const TILE_COLORS: Record<TileType, number> = {
  [TileType.Ground]:    0x1a1a2e,
  [TileType.Path]:      0x2a2a3e,
  [TileType.BuildSlot]: 0x2e3a2e,
  [TileType.Spawn]:     0x44ff44,
  [TileType.Base]:      0xff4444,
};

/** Subtle highlight color drawn on the top edge of build slot tiles. */
const BUILD_SLOT_HIGHLIGHT = 0x4e5a4e;

/** Shadow color used beneath path tiles for a depth cue. */
const PATH_SHADOW_COLOR = 0x111122;

/** Dashed-border color for build slots. */
const BUILD_SLOT_BORDER = 0x5a7a5a;

/** Grid overlay line color and alpha. */
const GRID_LINE_COLOR = 0xffffff;
const GRID_LINE_ALPHA = 0.04;

/**
 * Stores run-time data about a single build-slot tile so that the game can
 * perform click-detection and placement logic.
 */
export interface BuildSlotInfo {
  /** Tile column index */
  tileX: number;
  /** Tile row index */
  tileY: number;
  /** World x of tile center */
  worldX: number;
  /** World y of tile center */
  worldY: number;
  /** The interactive rectangle game object for this slot */
  rect: Phaser.GameObjects.Rectangle;
}

/**
 * Maps TileType enum values to the texture keys generated by AssetGenerator.
 * Used when sprite textures are available; falls back to graphics if missing.
 */
const TILE_TEXTURE_KEYS: Partial<Record<TileType, string>> = {
  [TileType.Ground]:    'tile-ground',
  [TileType.Path]:      'tile-path',
  [TileType.BuildSlot]: 'tile-build',
  [TileType.Spawn]:     'tile-spawn',
  [TileType.Base]:      'tile-base',
};

/**
 * TilemapRenderer -- draws a tile-based map onto a Phaser scene using
 * coloured rectangle primitives (no sprite assets required).
 *
 * When generated tile textures are available (from AssetGenerator), the
 * renderer layers sprites behind the interactive elements for a richer look.
 *
 * Usage:
 *   const renderer = new TilemapRenderer(scene, mapConfig);
 *   renderer.render();
 *   const slots = renderer.getBuildSlots();
 *   const waypoints = renderer.getPathPoints();
 */
export class TilemapRenderer {
  private scene: Phaser.Scene;
  private map: MapConfig;
  private buildSlots: BuildSlotInfo[] = [];
  private graphics!: Phaser.GameObjects.Graphics;
  /** Whether generated tile textures are available. */
  private hasTextures: boolean = false;

  constructor(scene: Phaser.Scene, map: MapConfig) {
    this.scene = scene;
    this.map = map;
  }

  // -----------------------------------------------------------------------
  // Public API
  // -----------------------------------------------------------------------

  /**
   * Draw the entire tilemap: ground, path, build slots, spawn, base,
   * grid overlay, and depth cues.
   */
  render(): void {
    this.graphics = this.scene.add.graphics();
    this.hasTextures = this.scene.textures.exists('tile-ground');

    // Draw tiles bottom-to-top so that shadow layers sit behind path tiles.
    this.drawShadows();
    this.drawTiles();
    this.drawBuildSlotDecorations();
    this.drawGridOverlay();
  }

  /**
   * Returns an array of build-slot metadata objects. Each slot contains tile
   * coordinates, world coordinates, and the interactive rectangle so that
   * the calling code can attach pointer events.
   */
  getBuildSlots(): BuildSlotInfo[] {
    return this.buildSlots;
  }

  /**
   * Converts the map's tile-coordinate path points into world-coordinate
   * waypoints (centre of each tile).  Enemy movement systems should follow
   * these points in order.
   */
  getPathPoints(): { x: number; y: number }[] {
    return this.map.pathPoints.map((p) => ({
      x: p.x * TILE_SIZE + TILE_SIZE / 2,
      y: p.y * TILE_SIZE + TILE_SIZE / 2,
    }));
  }

  // -----------------------------------------------------------------------
  // Internal rendering
  // -----------------------------------------------------------------------

  /**
   * Draw a subtle shadow offset beneath every path tile to give the path
   * a slight recessed look.
   */
  private drawShadows(): void {
    const shadowOffset = 3;
    this.graphics.fillStyle(PATH_SHADOW_COLOR, 0.5);

    const rows = this.map.grid.length;
    const cols = this.map.grid[0]?.length ?? 0;

    for (let row = 0; row < rows; row++) {
      for (let col = 0; col < cols; col++) {
        const tile = this.map.grid[row][col];
        if (
          tile === TileType.Path ||
          tile === TileType.Spawn ||
          tile === TileType.Base
        ) {
          this.graphics.fillRect(
            col * TILE_SIZE + shadowOffset,
            row * TILE_SIZE + shadowOffset,
            TILE_SIZE,
            TILE_SIZE,
          );
        }
      }
    }
  }

  /**
   * Iterate over every cell in the grid and draw the appropriate coloured
   * rectangle.  Build-slot tiles are created as interactive Phaser
   * Rectangle game objects so that pointer events can be wired up later.
   */
  private drawTiles(): void {
    const rows = this.map.grid.length;
    const cols = this.map.grid[0]?.length ?? 0;

    for (let row = 0; row < rows; row++) {
      for (let col = 0; col < cols; col++) {
        const tileValue = this.map.grid[row][col] as TileType;
        const worldX = col * TILE_SIZE + TILE_SIZE / 2;
        const worldY = row * TILE_SIZE + TILE_SIZE / 2;

        if (tileValue === TileType.BuildSlot) {
          // Layer a tile sprite behind the interactive rectangle if textures exist
          if (this.hasTextures) {
            const textureKey = TILE_TEXTURE_KEYS[TileType.BuildSlot];
            if (textureKey && this.scene.textures.exists(textureKey)) {
              this.scene.add.sprite(worldX, worldY, textureKey);
            }
          }

          // Build slots are interactive Rectangle game objects (kept for click detection).
          // When textures are present, the rectangle is transparent to reveal the sprite beneath.
          const fillColor = this.hasTextures ? 0x000000 : TILE_COLORS[TileType.BuildSlot];
          const fillAlpha = this.hasTextures ? 0 : 1;
          const rect = this.scene.add
            .rectangle(worldX, worldY, TILE_SIZE, TILE_SIZE, fillColor, fillAlpha)
            .setInteractive({ useHandCursor: true });

          this.buildSlots.push({
            tileX: col,
            tileY: row,
            worldX,
            worldY,
            rect,
          });
        } else if (this.hasTextures) {
          // Use tile sprite textures when available
          const textureKey = TILE_TEXTURE_KEYS[tileValue];
          if (textureKey && this.scene.textures.exists(textureKey)) {
            this.scene.add.sprite(worldX, worldY, textureKey);
          } else {
            // Fallback to graphics for unknown tile types
            const color = TILE_COLORS[tileValue] ?? TILE_COLORS[TileType.Ground];
            this.graphics.fillStyle(color, 1);
            this.graphics.fillRect(
              col * TILE_SIZE,
              row * TILE_SIZE,
              TILE_SIZE,
              TILE_SIZE,
            );
          }
        } else {
          // Non-interactive tiles are drawn with the shared graphics context
          // for better draw-call batching.
          const color = TILE_COLORS[tileValue] ?? TILE_COLORS[TileType.Ground];
          this.graphics.fillStyle(color, 1);
          this.graphics.fillRect(
            col * TILE_SIZE,
            row * TILE_SIZE,
            TILE_SIZE,
            TILE_SIZE,
          );
        }
      }
    }
  }

  /**
   * Draw decorative details on build-slot tiles:
   *  - A dashed border to make them visually distinct from ground
   *  - A lighter top edge as a subtle depth / bevel cue
   */
  private drawBuildSlotDecorations(): void {
    for (const slot of this.buildSlots) {
      const x = slot.tileX * TILE_SIZE;
      const y = slot.tileY * TILE_SIZE;

      // --- Lighter top edge (depth highlight) ---
      this.graphics.fillStyle(BUILD_SLOT_HIGHLIGHT, 0.6);
      this.graphics.fillRect(x, y, TILE_SIZE, 3);

      // --- Dashed border ---
      this.graphics.lineStyle(1, BUILD_SLOT_BORDER, 0.8);
      const dashLen = 6;
      const gapLen = 4;

      // Top & bottom edges
      for (let dx = 0; dx < TILE_SIZE; dx += dashLen + gapLen) {
        const segEnd = Math.min(dx + dashLen, TILE_SIZE);
        // top
        this.graphics.beginPath();
        this.graphics.moveTo(x + dx, y);
        this.graphics.lineTo(x + segEnd, y);
        this.graphics.strokePath();
        // bottom
        this.graphics.beginPath();
        this.graphics.moveTo(x + dx, y + TILE_SIZE);
        this.graphics.lineTo(x + segEnd, y + TILE_SIZE);
        this.graphics.strokePath();
      }

      // Left & right edges
      for (let dy = 0; dy < TILE_SIZE; dy += dashLen + gapLen) {
        const segEnd = Math.min(dy + dashLen, TILE_SIZE);
        // left
        this.graphics.beginPath();
        this.graphics.moveTo(x, y + dy);
        this.graphics.lineTo(x, y + segEnd);
        this.graphics.strokePath();
        // right
        this.graphics.beginPath();
        this.graphics.moveTo(x + TILE_SIZE, y + dy);
        this.graphics.lineTo(x + TILE_SIZE, y + segEnd);
        this.graphics.strokePath();
      }
    }
  }

  /**
   * Draw a faint grid overlay across the entire map so tile boundaries are
   * just barely visible.
   */
  private drawGridOverlay(): void {
    this.graphics.lineStyle(1, GRID_LINE_COLOR, GRID_LINE_ALPHA);

    const rows = this.map.grid.length;
    const cols = this.map.grid[0]?.length ?? 0;

    // Vertical lines
    for (let col = 0; col <= cols; col++) {
      this.graphics.beginPath();
      this.graphics.moveTo(col * TILE_SIZE, 0);
      this.graphics.lineTo(col * TILE_SIZE, rows * TILE_SIZE);
      this.graphics.strokePath();
    }

    // Horizontal lines
    for (let row = 0; row <= rows; row++) {
      this.graphics.beginPath();
      this.graphics.moveTo(0, row * TILE_SIZE);
      this.graphics.lineTo(cols * TILE_SIZE, row * TILE_SIZE);
      this.graphics.strokePath();
    }
  }
}
